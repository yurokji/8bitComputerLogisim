PC_INC =            0b1000000000000000000000000000000000000000000000000000000000000000
PC_S =              0b0100000000000000000000000000000000000000000000000000000000000000
PC_E =              0b0010000000000000000000000000000000000000000000000000000000000000
MAR_S =             0b0001000000000000000000000000000000000000000000000000000000000000
IR_S =              0b0000100000000000000000000000000000000000000000000000000000000000
RAM_S =             0b0000010000000000000000000000000000000000000000000000000000000000
RAM_E =             0b0000001000000000000000000000000000000000000000000000000000000000
ACC_S =             0b0000000100000000000000000000000000000000000000000000000000000000
ACC_E =             0b0000000010000000000000000000000000000000000000000000000000000000
RA_S =              0b0000000001000000000000000000000000000000000000000000000000000000
RA_E =              0b0000000000100000000000000000000000000000000000000000000000000000
RB_S =              0b0000000000010000000000000000000000000000000000000000000000000000
RB_E =              0b0000000000001000000000000000000000000000000000000000000000000000
TMP_S =             0b0000000000000100000000000000000000000000000000000000000000000000
CI_E =              0b0000000000000010000000000000000000000000000000000000000000000000
IOCLK_S =           0b0000000000000001000000000000000000000000000000000000000000000000
IOCLK_E =           0b0000000000000000100000000000000000000000000000000000000000000000
FLAG_S =            0b0000000000000000010000000000000000000000000000000000000000000000
FLAG_E =            0b0000000000000000001000000000000000000000000000000000000000000000
FLAG_CLR =          0b0000000000000000000100000000000000000000000000000000000000000000
IN_OUT =            0b0000000000000000000010000000000000000000000000000000000000000000
DATA_ADDR =         0b0000000000000000000001000000000000000000000000000000000000000000
TEST_C =            0b0000000000000000000000100000000000000000000000000000000000000000
TEST_A =            0b0000000000000000000000010000000000000000000000000000000000000000
TEST_E =            0b0000000000000000000000001000000000000000000000000000000000000000
TEST_Z =            0b0000000000000000000000000100000000000000000000000000000000000000
IR_E = 		    	0b0000000000000000000000000010000000000000000000000000000000000000
SP_INC =            0b0000000000000000000000000001000000000000000000000000000000000000
SP_DEC =            0b0000000000000000000000000000100000000000000000000000000000000000
SP_S =              0b0000000000000000000000000000010000000000000000000000000000000000
SP_E =              0b0000000000000000000000000000001000000000000000000000000000000000
HLT_E =             0b0000000000000000000000000000000100000000000000000000000000000000

END_INST =          0b0000000000000000000000000000000010000000000000000000000000000000
TMP_C =          	0b0000000000000000000000000000000001000000000000000000000000000000
INT_CHK =          	0b0000000000000000000000000000000000100000000000000000000000000000
INT_E =          	0b0000000000000000000000000000000000010000000000000000000000000000
EVAC_END =         	0b0000000000000000000000000000000000001000000000000000000000000000
GMOD_CLK_S =   		0b0000000000000000000000000000000000000100000000000000000000000000


# 암시 플래그 초기화 명령어 

# 인터럽트 발생시
# INT_CHK 체크 후 만약 INTR이 있다면 INT_ON이 되어 END_INST 되지 않고 다음 스텝을 수행
# 먼저 스택에 PC를 PUSH
# 그리고 스택에 플레그 레지스터 데이터를 PUSH
# 그리고 인터럽트 서비스 루틴으로 점프
# 인터럽트 서비스 루틴 수행후 RETI로 복귀
# RETI:  
# 1) 스택에 맨 위에 있는 첫값(플레그 레지스터 데이터)를 POP하여 플레그 레지스터를 복원
# 2) 스택 그 다음에 있는 값(PC주소)를 POP하여 PC를 복귀 


# # 1) 스택에 PC를 먼저 PUSH
# SP_DEC | SP_E | MAR_S, PC_E | RAM_S, 
# # 2) 스택에 플레그 레지스터를 PUSH
# SP_DEC | SP_E | MAR_S, FLAG_E | RAM_S, 
# # 3) 그리고 인터럽트 서비스 루틴으로 점프
# MAR_S | PC_E, PC_S,
# # 4) 스택에 맨 위에 있는 첫값(플레그 레지스터 데이터)를 POP하여 플레그 레지스터를 복원
# SP_E | MAR_S, RAM_E  | FLAG_S | SP_INC,
# # 5) 스택 그 다음에 있는 값(PC주소)를 POP하여 PC를 복귀 
# SP_INC, SP_E | MAR_S, RAM_E | PC_S




CLF =       [0x06, FLAG_CLR, INT_CHK, END_INST]



# 암시 시스템 종료 명령어 
HLT =       [0x99, HLT_E]
# 암시 대기 명령어
NOP =       [0x90, 0, 0, 0, INT_CHK, END_INST]



# 레지스터-레지스터 RAM 로드 명령어
LD =        [0x22, RA_E | MAR_S, RAM_E  | RB_S, INT_CHK, END_INST]
LDI =       [0x23, PC_E | MAR_S, PC_INC | RAM_E | MAR_S, RAM_E | RB_S, INT_CHK, END_INST]
LDN =        [0x24, RA_E | MAR_S, PC_INC |RAM_E  | MAR_S, RB_S, INT_CHK, END_INST]
# 레지스터-레지스터 RAM 저장 명령어
ST=         [0x28, RA_E | MAR_S, RB_E   | RAM_S, END_INST]
STI=        [0x29, PC_E | MAR_S, PC_INC | RAM_E | MAR_S, RB_E | RAM_S, INT_CHK, END_INST]

# 레지스터 입출력 명령어
INPORT =   [0x71,  GMOD_CLK_S, INT_CHK, END_INST] 
OUTPORT =   [0x72, GMOD_CLK_S, INT_CHK, END_INST] 
IND =       [0x77, RB_S | IOCLK_E, INT_CHK, END_INST]
INA =       [0x78, RB_S | IOCLK_E | DATA_ADDR, INT_CHK, END_INST]
OUTD =      [0x79, RB_E | IOCLK_S | IN_OUT, INT_CHK, END_INST]
OUTA =      [0x7a, RB_E | IOCLK_S | IN_OUT | DATA_ADDR, INT_CHK, END_INST]




# 레지스터-레지스터 데이터 이동 명령어
MOV = 		[0x1a, RA_E | RB_S, INT_CHK, END_INST]
# 레지스터-즉시 데이터 이동 명령어 (16비트 짧은 데이터)
MOVI =      [0x1b, PC_E | MAR_S, RAM_E | RB_S | PC_INC, INT_CHK, END_INST] 


# 스택 포인터에 값 로드
MVXI =      [0x1c, PC_E | MAR_S, RAM_E | SP_S | PC_INC, INT_CHK, END_INST]
PUSH =      [0x1d, SP_E | MAR_S, RB_E | RAM_S | SP_DEC, INT_CHK, END_INST]
POP =       [0x1e, SP_E | MAR_S, RAM_E  | RB_S | SP_INC, INT_CHK, END_INST]
CALL =      [0x60, SP_E | TMP_C | MAR_S, PC_E | ACC_S, PC_INC, SP_E | MAR_S, PC_E | RAM_S, ACC_E | MAR_S, SP_DEC | RAM_E | PC_S, INT_CHK, END_INST]
RET =       [0x61, SP_INC, SP_E | MAR_S, RAM_E | PC_S, INT_CHK, END_INST]

# 레지스터-레지스터  무조건 분기 명령어 
JMP =      [0x3a, PC_S | RB_E, INT_CHK, END_INST]
# 즉시 무조건 분기 명령어 (24비트 긴 주소)
JPI =      [0x3b, MAR_S | PC_E, PC_S  | RAM_E, INT_CHK, END_INST]


# 즉시 조건 분기 명령어 (24비트 주소)
BRC =       [0x41, PC_E | MAR_S, TEST_C, PC_INC, INT_CHK, END_INST,  RAM_E | PC_S, INT_CHK, END_INST]
BRA =       [0x42, PC_E | MAR_S, TEST_A, PC_INC, INT_CHK, END_INST,  RAM_E | PC_S, INT_CHK, END_INST]
BRE =       [0x43, PC_E | MAR_S, TEST_E, PC_INC, INT_CHK, END_INST,  RAM_E | PC_S, INT_CHK, END_INST]
BRZ =       [0x44, PC_E | MAR_S, TEST_Z, PC_INC, INT_CHK, END_INST,  RAM_E | PC_S, INT_CHK, END_INST]
BRNC =       [0x48, PC_E | MAR_S, TEST_C, PC_INC, INT_CHK, END_INST,  RAM_E | PC_S, INT_CHK, END_INST]
BRNA =       [0x49, PC_E | MAR_S, TEST_A, PC_INC, INT_CHK, END_INST,  RAM_E | PC_S, INT_CHK, END_INST]
BRNE =       [0x4a, PC_E | MAR_S, TEST_E, PC_INC, INT_CHK, END_INST,  RAM_E | PC_S, INT_CHK, END_INST]
BRNZ =       [0x4b, PC_E | MAR_S, TEST_Z, PC_INC, INT_CHK, END_INST,  RAM_E | PC_S, INT_CHK, END_INST]


#Define the opcode and DECODE/EXECUTION steps of ALU Instructions
# REG-REG MODE
ADD =       [0xc0, RB_E | TMP_S, ACC_S | RA_E | CI_E | FLAG_S, ACC_E | RB_S | TMP_C, INT_CHK, END_INST]
SUB =       [0xc1, RB_E | TMP_S, ACC_S | RA_E | CI_E | FLAG_S, ACC_E | RB_S | TMP_C, INT_CHK, END_INST]
SHR =       [0xc8, ADD[1], ADD[2], ADD[3], ADD[4], ADD[5]]
SHL =       [0xc9, ADD[1], ADD[2], ADD[3], ADD[4], ADD[5]]
NOT =       [0xca, ADD[1], ADD[2], ADD[3], ADD[4], ADD[5]]
AND =       [0xcb, ADD[1], ADD[2], ADD[3], ADD[4], ADD[5]]
OR =        [0xcc, ADD[1], ADD[2], ADD[3], ADD[4], ADD[5]]
XOR =       [0xcd, ADD[1], ADD[2], ADD[3], ADD[4], ADD[5]]
CMP =       [0xcf, ADD[1], ADD[2], TMP_C, ADD[4], ADD[5]]
INC =       [0xc2, RB_E  | CI_E | ACC_S | FLAG_S, ACC_E | RB_S, INT_CHK, END_INST]
DEC =       [0xc3, RB_E  | CI_E | ACC_S | FLAG_S, ACC_E | RB_S, INT_CHK, END_INST]



# REG-Immediate Mode 
ADI =       [0xd0, PC_E  | MAR_S,  RAM_E | TMP_S | PC_INC,  RB_E  | CI_E  | ACC_S  | FLAG_S, ACC_E | RB_S | TMP_C, INT_CHK, END_INST]
SBI =       [0xd1, ADI[1], ADI[2], ADI[3], ADI[4], ADI[5], ADI[6]]
SRI =       [0xd8, ADI[1], ADI[2], ADI[3], ADI[4], ADI[5], ADI[6]]
SLI =       [0xd9, ADI[1], ADI[2], ADI[3], ADI[4], ADI[5], ADI[6]]
NTI =       [0xda, ADI[1], ADI[2], ADI[3], ADI[4], ADI[5], ADI[6]]
ANI =       [0xdb, ADI[1], ADI[2], ADI[3], ADI[4], ADI[5], ADI[6]]
ORI =       [0xdc, ADI[1], ADI[2], ADI[3], ADI[4], ADI[5], ADI[6]]
XRI =       [0xdd, ADI[1], ADI[2], ADI[3], ADI[4], ADI[5], ADI[6]]
CPI =       [0xdf, ADI[1], ADI[2], ADI[3], TMP_C, ADI[5], ADI[6]]


# Interrupt Processing 
CALLI = [SP_DEC | SP_E | MAR_S, 
PC_E | RAM_S, 
SP_DEC | SP_E | MAR_S, 
FLAG_E | RAM_S, 
INT_E | PC_S, 
EVAC_END, END_INST]


RETI = [0xF, SP_E | MAR_S, RAM_E  | FLAG_S | SP_INC, SP_INC, SP_E | MAR_S, RAM_E | PC_S, END_INST]


# SP_E | MAR_S, RAM_E  | FLAG_S | SP_INC,
# SP_INC, SP_E | MAR_S, RAM_E | PC_S
# ]



#ALL Instructions
ALL_INSTRUCTIONS = [CLF, HLT, NOP,
					LD, ST, LDI, STI, 
					INPORT, OUTPORT, IND, INA, OUTD, OUTA,    
					MOV, MOVI, MVXI, PUSH,POP, CALL, RET, 
					JMP, JPI,
					BRC, BRA, BRE, BRZ, BRNC, BRNA, BRNE, BRNZ, 
                    ADD, SUB, INC, DEC,
                    SHR, SHL, NOT, AND, OR, XOR, CMP, 
                    ADI, SBI, SRI, SLI, NTI, ANI, ORI, XRI, CPI,
					RETI]

import array as arr

wordSize = 64
bitsForOP = 8
bitsForSteps = 4
oneCycle = 2 ** bitsForSteps
szROM = 2 ** (bitsForOP + bitsForSteps)
szROM_int = 2 ** 5
print('micro code ROM size: ', szROM, 'words')
# 4K x 64bit ROM 
data = arr.array('Q', [0] * szROM)
filename = 'mc16.bin'
f = open(filename, 'wb')

data_int = arr.array('Q', [0] * szROM_int)
intfilename = 'mc16_int.bin'
f_int = open(intfilename, 'wb')

# Steps for instruction fetch for ALL instructions (4096개, 4+8비트 = 헥스코드로 0x000~0xfff )
for i in range(0, 0x1000, oneCycle):
    if i == 0x990:
        data[i + 0] =      HLT_E
    else:
        data[i + 0] =       PC_E | MAR_S
        data[i + 1] =       RAM_E | IR_S | PC_INC

        
# Steps for decoding and execution for ALL instructions
for i, inst in enumerate(ALL_INSTRUCTIONS):
	if inst[0] == 0x00:
		print(inst[0])
	idx = inst[0] << 4
	for j in range(len(inst) - 1):
		data[idx+ 2 + j] = inst[j + 1]
		if inst[0] == 0x00:
			print(format(idx, '04x'), format(inst[j+1], '04x'))


data.tofile(f)
f.close()

for i, word in enumerate(CALLI):
	print(i)
	data_int[i] = word  


data_int.tofile(f_int)
f_int.close()